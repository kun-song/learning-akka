# 1.1 -> 1.4 基本介绍

## 基本概念

Actor 模型中，Actor 即为 **并发原语**，每个 Actor 可以与一个 **线程** 或 **进程** 类比，是干活的工人。

OOP 中一个对象可以访问、**修改** 另一个对象的属性，也可以调用另一个对象的 **方法**，若这些操作发生在 **一个线程** 中，则没有问题；但若 **多个线程** 同时读取、修改 **同一个** 值，就需要用 **锁** 进行同步。

Actor 与对象类似，但 Actor **不能** 被直接读取、修改、调用，Actor 只能通过 **消息** 与外界通信，整个过程是 **异步** 的。

Actor 每次只能处理 **一个** 消息，邮箱是存放消息的 **队列**，处理消息时，Actor 可以修改内部状态，创建更多 Actor，或将消息 **转发** 给其他 Actor。

使用 **Actor 系统** 表示多个 Actor 的集合，以及所有与该 Actor 集合相关的内容，比如地址、邮箱和配置等。

## Actor 解决了 race condition

Java 并发编程容易出错的原因是多线程同时修改 **共享状态**，但因为 Actor 每次只能处理一个消息，因此Actor 模型可以 **消除共享状态**，每个 Actor 的状态非常安全。

>共享状态导致 race condition
>
>状态由变量承载，共享状态就是 **共享变量**，更具体是指可被 **多个线程** 共享的变量。
>
>若多个线程同时对共享变量进行读取、修改、写入等操作，则线程间会对该共享变量竞争，导致线程间操作交叉，造成很难排查的错误。

例如，使用多线程对整数 `i` 执行 100000 次自增操作，因为 `++` 是由读、改、写 3 个子操作组成的，因此并非原子，就会发生 race condition：

```Scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

var i = 0
var j = 0

(1 to 100000).foreach(_ ⇒ Future(i = i + 1))
(1 to 100000).foreach(_ ⇒ j = j + 1)

// (71472,100000)
println(i, j)
```

* 多次运行该程序会发现，每次 `i` 的结果都不相同，而 `j` 一直是 100000，这就是共享状态造成的问题。

Java 通过对共享状态 **加锁**，来解决竞态条件，而 Actor 通过 **减少共享状态** 来解决该问题：

* 多线程之间不再通过共享状态通信，将状态转移到 **Actor 内部**，只有 Actor 自己才能访问自己的状态；
* Actor 之间使用 **不可变消息** 通信；
* Actor 每次只能处理 **一个消息**；

通过这 3 条措施，Actor 消除了 **所有共享状态**，大大简化了并发编程。

## 通过监督机制，实现容错

Actor 通过监督机制来实现容错，监督是指将出错 Actor 的处理责任交给其他 Actor（一般是父 Actor），通过监督机制，父 Actor 可以监控它的子 Actor，并可以根据子 Actor 的表现执行不同的操作。

监督机制对出错 Actor 的默认处理策略是 **重新创建**，可自定义任意合适的处理策略。

## 位置透明性

Akka 为 Actor 模型引入 **位置透明性** 的概念，即 Actor 的邮箱地址既可以是 **本地地址**，也可以是 **远程地址**，如此一来，一个 Actor 系统中的各个 Actor，就可以部署在 **多台机器** 上，从而实现可伸缩的 Akka 集群。
